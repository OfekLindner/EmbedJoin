# import numpy as np
# from numpy.random import default_rng
#
# dna_dict = {'A': 0, 'C': 1, 'G': 2, 'T': 3, 'P': 4}
#
#
# def get_LSH_sig(N, r, z, m):
#     """
#     :param N:   Length of the longest strand in S
#     :param r:   Number of CGK-embeddings for each input strand
#     :param z:   Number of hash functions used in LSH for each strand generated by CGK-embedding
#     :param m:   Length of the LSH signature
#     :return:    3-dimensional matrix D, where D[l,j] is the m bits-sampling (AND-construction)
#     """
#     return np.array([[default_rng().choice(3*N, size=m, replace=False) for _ in range(z)] for _ in range(r)])
#
#
# def hash_matrix(N):
#     """
#     :param N:   Length of the longest strand in S
#     :return:    Set of 3N functions R: Sigma (A,C,G,T) -> {0,1}
#     """
#     return np.random.randint(2, size=(3 * N, 4))
#
#
# def CGK_embedding(s, N, hm):
#     """
#     :param s:   DNA strand
#     :param N:   Length of the longest strand in S
#     :param hm:  Set of 3N functions R: Sigma (A,C,G,T) -> {0,1}
#     :return:    A strand of length 3N
#     """
#     embed_strand = np.zeros(3 * N, dtype=int)
#     idx = 0
#     for k in range(3 * N):
#         if idx >= len(s):
#             embed_strand[k] = dna_dict['P']
#         else:
#             embed_strand[k] = s[idx]
#             idx += hm[k][s[idx]]
#     return embed_strand
#
#
# def create_S(file_path):
#     """
#     :param file_path:   the path of the input file
#     :return:            Set of input strands
#     """
#     with open(file_path) as file:
#         lines = file.readlines()
#     return [[dna_dict[x] for x in line if x != '\n'] for line in lines]
#
#
# def preprocessing(S, r, z, m):
#     """
#     :param S:   Set of input strands
#     :param r:   Number of CGK-embeddings for each input strand
#     :param z:   Number of hash functions used in LSH for each strand generated by CGK-embedding
#     :param m:   Length of the LSH signature
#     :return:    S: Strings in S in the sorted order,
#                 T: Strings after CGK-embedding,
#                 D: Hash tables
#     """
#     S = sorted(S, key=len)
#     N = len(S[-1])  # length of the longest strand in S
#     D = get_LSH_sig(N, r, z, m)
#     HM = [hash_matrix(N) for _ in range(r)]
#     T = [[CGK_embedding(s, N, hm) for s in S] for hm in HM]
#     return S, np.array(T, dtype=int), D
#
#
# def EmbedJoin(K, r, z, m):
#     """
#     :param K:   ED Threshold
#     :param r:   Number of CGK-embeddings for each input strand
#     :param z:   Number of hash functions used in LSH for each strand generated by CGK-embedding
#     :param m:   Length of the LSH signature
#     :return:    Pairs (s_i,s_j): s_i,s_j from S, i != j s.t ED(s_i,s_j) <= K
#     """
#     S, T, D = preprocessing(create_S('input'), r, z, m)
#     bucket_dict = {}
#     C = set([])  # Collection of candidate pairs
#     for i, s in enumerate(S):
#         for l in range(r):
#             for j in range(z):
#                 t = T[l][i]
#                 d = D[l, j]
#                 m_sample = t[d]
#                 # [(l, j, tuple(m_sample))]
#                 bucket = bucket_dict.get((l, j, tuple(m_sample)), [])
#                 for sb in bucket:
#                     if len(S[i]) - len(S[sb]) <= K:
#                         C.add((i, sb))
#                     else:
#                         bucket.remove(sb)
#                 bucket.append(i)
#                 bucket_dict[(l, j, tuple(m_sample))] = bucket
#     return C, S
from util import EmbedJoin
from statistics import mean

if __name__ == '__main__':
    acc_list = []
    for i in range(100):
        EJ = EmbedJoin(threshold=3,num_of_embeddings=4,num_of_hash_func_in_LSH=4,length_of_LSH_sig=5)
        EJ.preprocessing("input")
        EJ.run()
        # EJ.print_pairs(EJ.candidate_pairs)
        EJ.varification_pairs()
        acc_list.append(EJ.accuracy())
    print("Acc = {}".format(mean(acc_list)))
    #
    # EJ.print_pairs(EJ.C)
