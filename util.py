import string
import numpy as np
from numpy.random import default_rng
from verification import EditDistDP

# Mapping from DNA symbols Chars to Integers
dna_symbol_dict = {'A': 0, 'C': 1, 'G': 2, 'T': 3, 'P': 4}
dna_symbol_dict_inv = ['A', 'C', 'G', 'T']


def input_set_create(input_file_path: string):
    """
    Create The set of input strings S
    :param input_file_path: the path of the input file

    :return: Set of input strands
    :rtype: List of Lists of Integers
    """
    with open(input_file_path) as file:
        lines = file.readlines()
    return [[dna_symbol_dict[x] for x in line if x != '\n'] for line in lines]


class EmbedJoin:
    def __init__(self, threshold: int, num_of_embeddings: int, num_of_hash_func_in_LSH: int, length_of_LSH_sig: int):
        """
        :param threshold: Edit distance threshold
        :param num_of_embeddings: Number of CGK-embeddings for each input string
        :param num_of_hash_func_in_LSH: Number of hash functions used in LSH for each string generated by CGK-embedding
        :param length_of_LSH_sig: Length of the LSH signature
        """
        self.K = threshold
        self.r = num_of_embeddings
        self.z = num_of_hash_func_in_LSH
        self.m = length_of_LSH_sig
        self.Sigma = 4

    def preprocessing(self, input_file_path):
        """
        Preprocessing Algorithm
        :param input_file_path:  the path of the input file

        :return: S: input strands in sorted order,
                 T: Strings after CGK-embedding,
                    D: Hash tables
        """
        S = sorted(input_set_create(input_file_path), key=len)
        self.S_dict = {i: s for i, s in enumerate(S)}
        self.N = len(S[-1])  # length of the longest strand in S
        self.D = self.LSH_matrix()
        self.R = self.symbols_hashing()
        self.T = self.embedding_create()

    def split_to_chunks(self, org_list):
        """
        Break a list into chunks of size m
        :param org_list: List of size m*z

        :return: List of z Lists of size m
        """
        return [org_list[i * self.m:(i + 1) * self.m] for i in range((len(org_list) + self.m - 1) // self.m)]

    def LSH_matrix(self):
        """
        Create matrix of all the LSH functions

        :return: 3-dimensional matrix D
                 l: the index of the current embedding process
                 j: the index of the current bits-sampling (OR-construction)
                 D[l,j]: the m bits-sampling (AND-construction)
        :rtype: D: Matrix of List of Integers
                D[l,j]: List of Integers
        """
        return np.array([self.split_to_chunks(default_rng().choice(3 * self.N, size=self.m * self.z, replace=False))
                         for _ in range(self.r)])

    def symbols_hashing(self):
        """
        Create List of functions sets
        each set for one embedding process
        Pi: {A,C,G,T} -> {0,1}

        :return: List of size r of Sets of 3N pi functions
        """
        return [np.random.randint(2, size=(3 * self.N, self.Sigma)) for _ in range(self.r)]

    def embedding_create(self):
        """
        Create Matrix T of size r x |S| of Embedded Strands

        :return: T[l][i]: the embedded strand of s_i at the l embedding process
        """
        return np.array([[self.CGK_embedding(s, currentR) for s in self.S_dict.values()] for currentR in self.R],
                        dtype=int)

    def CGK_embedding(self, s, curr_embedding_process_R):
        """
        Embed s to Strand of size 3N
        :param s: DNA strand
        :param curr_embedding_process_R: set of Pi functions

        :return: A strand of length 3N
        """
        embed_strand = np.zeros(3 * self.N, dtype=int)
        idx = 0
        for k in range(3 * self.N):
            if idx >= len(s):
                embed_strand[k] = dna_symbol_dict['P']
            else:
                embed_strand[k] = s[idx]
                idx += curr_embedding_process_R[k][s[idx]]
        return embed_strand

    def run(self):
        bucket_dict = {}
        C = set([])  # Collection of candidate pairs
        for strand_idx, s in self.S_dict.items():
            for embedding_process_idx in range(self.r):
                for LSH_idx in range(self.z):
                    t = self.T[embedding_process_idx][strand_idx]
                    LSH_mask = self.D[embedding_process_idx, LSH_idx]
                    m_sample = t[LSH_mask]
                    bucket_key = (embedding_process_idx, LSH_idx) + tuple(m_sample)
                    bucket = bucket_dict.get(bucket_key, [])
                    for sb in bucket:
                        if len(self.S_dict[strand_idx]) - len(self.S_dict[sb]) <= self.K:
                            C.add((strand_idx, sb))
                        else:
                            bucket.remove(sb)
                    bucket.append(strand_idx)
                    bucket_dict[bucket_key] = bucket
        self.candidate_pairs = C

    def print_pairs(self, pairs):
        for i1, i2 in pairs:
            s1 = ''.join([dna_symbol_dict_inv[j] for j in self.S_dict[i1]])
            s2 = ''.join([dna_symbol_dict_inv[j] for j in self.S_dict[i2]])
            print("s1: {}, s2: {}".format(s1, s2))

    def varification_pairs(self):
        self.Pos = set([])
        self.Neg = set([])
        self.tot_pairs = 0
        for i1, s1 in self.S_dict.items():
            for i2, s2 in list(self.S_dict.items())[i1:]:
                if i1 == i2:
                    continue
                self.tot_pairs += 1
                if EditDistDP(s1, s2) <= self.K:
                    self.Pos.add((i1, i2))
                else:
                    self.Neg.add((i1, i2))

    def accuracy(self):
        true_neg = 0
        true_pos = 0
        for s1, s2 in self.Neg:
            if (s1, s2) not in self.candidate_pairs and (s2, s1) not in self.candidate_pairs:
                true_neg += 1
        for s1, s2 in self.Pos:
            if (s1, s2) in self.candidate_pairs or (s2, s1) in self.candidate_pairs:
                true_pos += 1
        acc = (true_neg + true_pos) / self.tot_pairs
        # print("Acc = {}".format(acc*100))
        return acc*100